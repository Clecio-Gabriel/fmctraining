A)

data Nat
    O : Nat
    S : Nat → Nat

List: Type α → List α
data List α
    [] : List α
    x :: [] : α x → List α → List α


Length : List Nat → Nat
Length [] = O
Length _::xs = S (length xs)

(++) : List α → List α → List α
[] ++ ys = ys
(x::xs) ++ ys = x :: (xs++ys)

reverse : List Nat → List Nat
reverse [] = []
reverse (xs::x) = 

map : (α → β) → (List α → List β)
map f [] = []
map f (x:xs) = f x :: map f xs 

filter : (α → Bool) → (Lα → Lα)
filter p [] = []
filter p [x:xs] = 
                | p x == True       = x : filter p xs
                | otherwise         = filter p xs



⊢ length (xs++ys) = length xs + length ys

DEMONS.:
Por indução em xs
caso []:
--alvo: length ([]++ys) = length [] + length ys
calculamos:
    length ([]++ys)
        = length ys     [(++).1]
        = 0 + length ys [zero_add]
        = length [] + length ys [length.1]

caso (x:xs):
-- H.I.: length (l++ys) = length l + length ys
-- ALVO: length ((k::l)++ys) = length (k::l) + length ys
calculamos:
    length ((k::l)++ys)
        = length (k :: (l ++ ys)) [(++).1]
        = S(length(l ++ ys))      [length.2]
        = S(length l + length ys) [H.I.]
    length (k::l) + length ys =
        = length ys + length (k::l) [add_comm]
        = length ys + S(length l)   [length.2]
        = S(length ys + length l)   [add_succ]
        = S(length l + length ys)   [add_comm]
Imediato◻️


```lean
⊢ (∀m, n, d : Nat) [d · (m + n) = dm + dn]

Seja a, b : Nat

DEMONS.:
Por indução em d.

Caso O:
--ALVO: 0 · (a + b) = 0·a + 0·b
Calculamos:
    0 · (a + b)
        = (a + b) · 0 [(·)-com]
        = 0    [(·).1]
    0·a + 0·b
        = 0 + 0 [(·).1]
        = 0     [(+).1]

Caso Sk:
--H.I.: k · (a + b) = ka + kb
--ALVO: Sk · (a + b) = Sk·a + Sk·b
Calculamos:
    Sk · (a + b)
        = (a + b) · Sk  [(·)-com]
        = (a + b) · k + (a + b) [(·).2]
        = k · (a + b) + (a + b) [(·)-com]
        = ka + kb + a + b   [←Hip.]
        = ka + a + kb + b   [(+)-com]
        = Sk · a + Sk · b   [←(·).2]
Imediato◻️
```
